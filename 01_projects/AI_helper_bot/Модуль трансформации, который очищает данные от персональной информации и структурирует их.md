---
class: note
area:
tags:
created:
---
**MOC:**

# Модуль трансформации, который очищает данные от персональной информации и структурирует их

> [!tldr] ai review
> 

Отличный вопрос! Структура документа для загрузки в RAG - это действительно критически важный момент, который напрямую влияет на качество поиска и генерации ответов. Давайте разберем это максимально подробно, потому что правильная структуризация данных на этапе загрузки может сделать разницу между ботом, который работает хорошо, и ботом, который работает превосходно.

## Философия структурирования данных для RAG

Начну с фундаментального принципа, который важно понимать. RAG-система работает на основе семантического поиска - она ищет не по точным совпадениям ключевых слов, а по смыслу. Когда бот задает вопрос RAG, система превращает этот вопрос в математический вектор, который представляет смысл запроса, а затем ищет документы, чьи векторы наиболее близки к вектору запроса в многомерном пространстве.

Из этого следует ключевое понимание: каждый отдельный фрагмент текста, который вы загружаете в RAG, должен быть семантически цельным и самодостаточным. Представьте, что каждый кусочек информации - это отдельная карточка в библиотечном каталоге. Когда приходит запрос, RAG показывает боту несколько наиболее подходящих карточек. Если на одной карточке написано начало мысли, а продолжение на другой, или если карточка содержит информацию о пяти разных темах одновременно, система будет работать плохо.

## Основные компоненты структуры документа

Каждый документ, который вы загружаете в RAG, должен состоять из двух основных частей: самого содержимого и метаданных. Содержимое - это непосредственно текст, который будет использоваться AI для генерации ответа. Метаданные - это структурированная информация о документе, которая помогает фильтровать и ранжировать результаты поиска.

Начнем с содержимого. Оптимальная длина одного фрагмента текста для RAG обычно составляет от трехсот до тысячи токенов, что примерно соответствует от двухсот до семисот слов. Это не жесткое правило, но хорошая отправная точка. Фрагмент должен быть достаточно большим, чтобы содержать законченную мысль с контекстом, но достаточно маленьким, чтобы быть сфокусированным на одной теме.

Представьте, что у вас есть длинная статья из Confluence о настройке интеграции с внешними системами. Эта статья описывает интеграцию с 1С, с CRM и с почтовым сервером. Если вы загрузите всю статью как один документ, то когда пользователь спросит про 1С, RAG вернет весь документ, включая информацию про CRM и почту, которая не нужна. Это засоряет контекст для AI и снижает качество ответа.

Вместо этого, статью нужно разбить на логические фрагменты. Раздел про 1С становится отдельным документом. Раздел про CRM - еще одним. Раздел про почтовый сервер - третьим. Теперь, когда придет запрос про 1С, RAG вернет именно тот фрагмент, который релевантен, без шума.

Но здесь возникает тонкость. Если вы просто механически разрежете статью на куски по триста слов каждый, вы можете разорвать логические связи. Например, в начале раздела про 1С может быть написано "для начала нужно установить соединение", а конкретные шаги - дальше. Если этот текст попадет в разные фрагменты, каждый из них потеряет смысл.

Поэтому разбиение должно быть умным, учитывающим структуру документа. Если исходный документ имеет заголовки и подзаголовки, используйте их как границы для разбиения. Каждый подраздел с заголовком становится отдельным фрагментом. При этом важно сохранять контекст - в начало каждого фрагмента добавляйте путь заголовков, чтобы было понятно, где находится этот кусок в общей структуре.

## Конкретная структура для вашей системы Pyrus

Давайте теперь спроектируем конкретную структуру документа для вашего случая. Я предлагаю использовать JSON-формат для передачи данных в RAG через API, потому что это стандартный, легко читаемый и гибкий формат.

Каждый документ будет выглядеть примерно так. Есть поле document_id - это уникальный идентификатор документа, который позволяет ссылаться на него из других систем. Для страниц Confluence это может быть их внутренний ID, для тикетов Pyrus - номер тикета с префиксом. Например, "confluence_12345" или "pyrus_ticket_67890".

Поле content содержит основной текст. Это самая важная часть - именно этот текст будет превращен в вектор и использован для семантического поиска. Текст должен быть очищен от форматирования, но структурирован понятно. Если это инструкция с шагами, они должны быть пронумерованы. Если это описание проблемы и решения, они должны быть явно разделены.

Например, для фрагмента из Confluence про интеграцию с 1С, content может выглядеть так: "Настройка интеграции с 1С. Интеграция с 1С позволяет автоматически синхронизировать данные о контрагентах между системами. Для настройки выполните следующие шаги. Шаг первый: создайте новую форму интеграции в разделе Настройки. Шаг второй: укажите URL эндпоинта 1С и аутентификационные данные. Шаг третий: настройте маппинг полей между Pyrus и 1С. Важно: убедитесь что версия 1С не ниже 8.3, так как в более ранних версиях отсутствует необходимый API."

Обратите внимание как структурирован текст. Есть заголовок, который сразу говорит о чем документ. Есть краткое описание зачем это нужно. Есть четкие пронумерованные шаги. Есть важное примечание. Все это делает документ самодостаточным - даже если AI получит только этот фрагмент, он сможет дать полный ответ пользователю.

Теперь перейдем к метаданным. Это структурированные поля, которые описывают документ и позволяют фильтровать результаты поиска. Я предлагаю следующий набор метаданных для вашей системы.

Поле source_type указывает откуда пришел документ. Возможные значения: "confluence", "pyrus_ticket", "manual_update". Это позволит фильтровать поиск по источникам. Например, если бот ищет ответ на технический вопрос, можно дать больший вес документам из Confluence, где официальная документация. Если же вопрос про конкретную проблему пользователя, документы из закрытых тикетов могут быть более релевантны.

Поле source_id содержит идентификатор документа в исходной системе. Для Confluence это ID страницы, для Pyrus - номер тикета. Это позволяет вернуться к оригиналу если нужно.

Поле category - это та же категоризация, которую вы используете для тикетов. Значения: "integrations", "routing", "platform_functionality", "technical_issues", "access_rights", "reporting", "other". Это критически важное поле для фильтрации. Когда бот категоризирует входящий тикет как "интеграции", запрос к RAG может включать фильтр чтобы искать только в документах с category равным "integrations". Это резко повышает точность поиска.

Поле subcategory позволяет детализировать категорию. Например, для категории "integrations" подкатегории могут быть "1c", "email", "crm", "api". Для категории "platform_functionality" - "forms", "routing_rules", "workflows", "reports". Это дает еще более точное таргетирование поиска.

Поле title содержит заголовок документа. Для страниц Confluence это заголовок страницы, для тикетов - тема обращения. Заголовок важен, потому что RAG может искать не только по основному тексту, но и по заголовку, причем часто с большим весом.

Поле tags - это массив ключевых слов, которые характеризуют документ. Например, для документа про интеграцию с 1С теги могут быть: "1c", "integration", "synchronization", "contractors", "api". Эти теги можно извлекать автоматически из текста с помощью NLP, или брать из исходной системы если там есть теги.

Поле created_at и updated_at - временные метки создания и последнего обновления документа. Это позволяет давать больший вес более свежим документам или фильтровать устаревшую информацию.

Поле version_id - это идентификатор версии данных в RAG, о котором мы подробно говорили ранее. Это позволяет системе работать с разными версиями базы знаний.

Поле is_active - булевый флаг, указывающий активен ли этот документ в текущей версии. Неактивные документы не участвуют в поиске.

Поле language - язык документа. В вашем случае это скорее всего всегда "ru", но если в будущем появится англоязычная документация или многоязычная поддержка, этот фильтр будет полезен.

Поле confidence_score - это опциональное поле, которое может содержать оценку качества или полноты информации в документе. Например, документы из официальной документации Confluence могут иметь confidence_score равный единице, а документы из тикетов, где информация менее формализована - ноль восемь. Это позволит RAG ранжировать результаты с учетом надежности источника.

Поле view_count или usage_count - опциональная метрика, которая показывает, сколько раз этот документ был полезен в прошлом. Если определенный документ часто возвращается RAG и используется AI для генерации успешных ответов, его можно поднимать в рейтинге при будущих поисках.

## Пример полной структуры документа

Давайте соберем все вместе в конкретный пример JSON-документа, который ваш ETL-pipeline будет отправлять в RAG:

```json
{
  "document_id": "confluence_45678",
  "content": "Настройка интеграции с 1С для синхронизации контрагентов. Интеграция с 1С позволяет автоматически синхронизировать данные о контрагентах между Pyrus и 1С, избегая ручного ввода и ошибок. Для настройки интеграции выполните следующие действия. Шаг 1: В разделе Настройки выберите Интеграции и нажмите Добавить интеграцию. Шаг 2: Выберите тип интеграции 1С из списка доступных. Шаг 3: Укажите URL эндпоинта вашего сервера 1С в формате http://server:port/base/hs/exchange. Шаг 4: Введите логин и пароль пользователя 1С с правами на обмен данными. Шаг 5: Настройте маппинг полей - укажите какие поля Pyrus соответствуют каким полям в 1С. Стандартное соответствие: Название организации в Pyrus соответствует Наименование в 1С, ИНН соответствует ИНН, Адрес соответствует ЮрАдрес. Шаг 6: Настройте периодичность синхронизации - рекомендуется каждые 4 часа для актуальности данных. Шаг 7: Нажмите Сохранить и протестировать соединение. Важные замечания: Убедитесь что версия 1С не ниже 8.3, так как в более ранних версиях API может работать нестабильно. Для корректной работы интеграции в 1С должен быть установлен и настроен HTTP-сервис обмена данными. При возникновении ошибки 401 проверьте корректность логина и пароля. При ошибке таймаута увеличьте время ожидания в настройках интеграции.",
  
  "metadata": {
    "source_type": "confluence",
    "source_id": "45678",
    "category": "integrations",
    "subcategory": "1c",
    "title": "Настройка интеграции с 1С для синхронизации контрагентов",
    "tags": ["1c", "интеграция", "синхронизация", "контрагенты", "настройка", "api"],
    "created_at": "2025-11-15T10:30:00Z",
    "updated_at": "2025-12-01T14:20:00Z",
    "version_id": "2025-12-13_scheduled_01",
    "is_active": true,
    "language": "ru",
    "confidence_score": 1.0,
    "parent_document_id": "confluence_45600",
    "parent_document_title": "Руководство по интеграциям"
  }
}
```

Обратите внимание на несколько деталей. Поле content содержит весь текст одним блоком, но структурированный понятно с явными шагами и примечаниями. Метаданные содержат всю необходимую информацию для фильтрации и ранжирования. Есть parent_document_id который указывает на родительскую страницу в Confluence - это позволяет сохранить иерархическую структуру документации.

## Специфика структуры для разных источников

Важно понимать, что документы из разных источников должны структурироваться по-разному, учитывая специфику каждого источника.

Для страниц Confluence вы работаете с формализованной документацией. Эти страницы обычно хорошо структурированы, имеют заголовки, подзаголовки, списки. Ваша задача - сохранить эту структуру при разбиении на фрагменты. Если страница длинная и содержит несколько разделов, каждый раздел с подзаголовком становится отдельным документом в RAG. При этом в начало каждого фрагмента добавляется контекст - путь заголовков от корня страницы до текущего раздела.

Например, если в Confluence есть страница "Руководство по интеграциям" с подразделами "Интеграция с 1С", "Интеграция с CRM", "Интеграция с почтой", каждый подраздел становится отдельным документом. В поле content каждого документа в начале добавляется путь: "Руководство по интеграциям → Интеграция с 1С". Это дает контекст, который важен для понимания.

Для закрытых тикетов Pyrus структура будет другой. Тикет обычно содержит описание проблемы от пользователя и решение от сотрудника поддержки. Эти две части нужно четко разделить и структурировать. Я предлагаю format такой: "Проблема: [описание проблемы пользователя]. Решение: [шаги которые привели к решению]. Итог: [краткое резюме что было сделано]."

Например: "Проблема: Пользователь не может настроить автоматическую маршрутизацию задач по определенному подразделению, задачи падают на руководителя всей компании вместо руководителя подразделения. Решение: Проверили настройки формы и обнаружили что в правилах маршрутизации используется устаревший идентификатор подразделения после реорганизации. Обновили правило маршрутизации, указав актуальный идентификатор подразделения из справочника. Проверили работу на тестовой задаче, маршрутизация заработала корректно. Итог: Проблема решена обновлением идентификатора подразделения в правилах маршрутизации формы."

Такая структура делает тикет полезным источником знаний, потому что сразу понятно и в чем была проблема, и как она решалась. Когда придет похожий вопрос, RAG найдет этот документ, и AI сможет предложить аналогичное решение.

Важный момент - при извлечении информации из тикетов нужно быть избирательным. Не каждый закрытый тикет должен попадать в RAG. Только те тикеты, которые содержат ценную информацию о решении нетривиальной проблемы. Простые тикеты типа "как создать новую форму" не нужны, если эта информация уже есть в документации Confluence. Тикеты ценны именно реальными кейсами решения сложных или нестандартных ситуаций.

Для ручных актуализаций от сотрудников поддержки структура самая простая. Сотрудник уже формулирует информацию в понятном структурированном виде, готовом для загрузки. Ваша задача только очистить от персональных данных и добавить метаданные.

## Процесс очистки персональных данных в контексте структуры

Теперь давайте поговорим о том, как очистка персональных данных влияет на структуру документа. Это важно понимать, потому что наивная замена имен и email может разрушить смысл текста.

Представьте фрагмент из тикета: "Пользователь Иван Петров из компании Ромашка написал что не может настроить интеграцию." После простой замены получится: "Пользователь [USER] из компании [COMPANY] написал что не может настроить интеграцию." Формально персональные данные удалены, но текст стал менее читаемым и потерял некоторую структуру.

Я предлагаю более умный подход. Вместо токенов типа [USER] и [COMPANY], используйте более естественные замены которые сохраняют грамматику и читаемость. "Пользователь из организации-клиента не может настроить интеграцию." Или еще лучше, если контекст позволяет полностью убрать лишнюю информацию: "Не удается настроить интеграцию."

Для email-адресов и телефонов стратегия проще - они обычно не несут смысловой нагрузки в контексте описания проблемы, поэтому их можно просто удалять. "Отправьте файл на адрес support@example.com" становится "Отправьте файл в службу поддержки."

Названия конкретных компаний-клиентов заменяются на обобщения, но с сохранением контекста если он важен. "Компания Ромашка использует интеграцию с 1С версии 8.2" становится "Клиент использует интеграцию с 1С версии 8.2." Информация о версии 1С сохранена, потому что она важна, а конкретное название компании заменено.

Важно, что процесс очистки должен быть последним шагом перед формированием финальной структуры document. Сначала вы извлекаете данные из источника, структурируете их в нужный формат с разбиением на логические фрагменты, добавляете метаданные, и только потом запускаете очистку персональных данных на поле content. Это гарантирует, что персональные данные не попадут случайно в какие-то другие поля.

## Обогащение документов дополнительной информацией

Есть еще один продвинутый прием, который может значительно улучшить качество поиска в RAG. Это обогащение документов дополнительной семантической информацией, которой нет в исходном тексте, но которая помогает поиску.

Например, у вас есть документ про настройку интеграции с 1С. В тексте нигде не написано слово "синхронизация", хотя по сути это и есть синхронизация данных. Пользователь может спросить "как настроить синхронизацию с 1С", и RAG может не найти ваш документ, потому что слова "синхронизация" в нем нет.

Решение - добавить в метаданные поле synonyms или related_terms, которое содержит синонимы и связанные термины. Для документа про интеграцию с 1С это может быть: "синхронизация, обмен данными, экспорт, импорт, двусторонняя связь". Когда RAG будет строить вектор для документа, эти дополнительные термины повысят вероятность нахождения документа по разным формулировкам запроса.

Такое обогащение можно делать либо вручную при создании документации, либо автоматически с помощью NLP-моделей, которые извлекают ключевые концепции из текста и находят к ним синонимы.

## Итоговая рекомендация по структуре

Подводя итог всему сказанному, вот конкретная структура которую я рекомендую использовать для загрузки документов в ваш RAG. Каждый документ - это JSON-объект с двумя основными секциями.

Первая секция - это прямые поля на верхнем уровне. Поле document_id содержит уникальный идентификатор. Поле content содержит основной текст фрагмента, структурированный и очищенный от персональных данных. Размер обычно от двухсот до семисот слов, представляющий одну логическую единицу информации.

Вторая секция - это объект metadata с полями: source_type (откуда документ), source_id (идентификатор в исходной системе), category и subcategory (классификация по темам), title (заголовок), tags (массив ключевых слов), created_at и updated_at (временные метки), version_id (версия данных в RAG), is_active (активность документа), language (язык), confidence_score (оценка качества), parent_document_id (для иерархии), usage_count (количество успешных использований).

Эта структура универсальна для всех источников данных - Confluence, тикетов Pyrus, ручных актуализаций. Она обеспечивает и эффективный семантический поиск по содержимому, и точную фильтрацию по метаданным, и возможность аудита и улучшения базы знаний.

Самое важное при разработке модуля трансформации - это тестирование на реальных данных. Загрузите первую сотню документов, проверьте как работает поиск по разным запросам, проанализируйте какие документы находятся, а какие нет. На основе этого анализа корректируйте правила разбиения текста на фрагменты и состав метаданных. Структура должна эволюционировать вместе с накоплением опыта использования системы.

Есть ли какие-то специфические вопросы про структурирование конкретных типов данных, которые встречаются в вашей системе Pyrus? Может быть, есть особенности в структуре ваших документов Confluence или тикетов, которые нужно учесть?

### Additional materials