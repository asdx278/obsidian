---
class: note
area: professional
tags:
  - ai
created: 2025-12-13
---
**MOC:**

# Механизм версионирования данных в RAG для возможности отката изменений

> [!tldr] ai review
> 

Отличный вопрос! Версионирование данных в RAG - это действительно важный механизм, который я упомянул в архитектурном плане, и сейчас подробно объясню, как именно предлагаю его реализовать.

Давайте начнем с понимания самой проблемы. Представьте ситуацию: ваш ETL-pipeline обновил базу знаний в RAG новой информацией из Confluence и закрытых тикетов. Через несколько дней команда поддержки замечает, что бот начал давать странные или некорректные ответы. Оказывается, в новой порции данных была устаревшая или ошибочная информация, которая теперь "засоряет" результаты поиска в RAG. Без версионирования у вас нет простого способа вернуться к предыдущему состоянию базы знаний, которое работало корректно.

Версионирование решает эту проблему, позволяя вам "откатить" базу знаний к любому предыдущему состоянию, подобно тому, как Git позволяет откатить код к предыдущему коммиту.

## Концептуальная модель версионирования

В основе предлагаемого решения лежит идея, что каждый документ в RAG имеет не только содержание, но и версионные метаданные. Каждый раз, когда ETL-pipeline обновляет данные, создается новая версия базы знаний, и все документы помечаются этой версией. При этом старые версии документов не удаляются физически, а просто помечаются как неактивные.

Ключевая идея заключается в том, что RAG всегда работает с определенной активной версией. По умолчанию это последняя версия, но при необходимости вы можете переключить систему на работу с любой предыдущей версией.

## Техническая реализация

Версионирование реализуется на нескольких уровнях системы. Первый уровень - это расширение метаданных документов в RAG. Каждый документ при загрузке получает дополнительные атрибуты, которые описывают его версионный контекст.

Когда ETL-pipeline готовится загрузить новую порцию данных в RAG, первым шагом он генерирует уникальный идентификатор версии. Этот идентификатор может быть построен по разным принципам, но я предлагаю использовать комбинацию временной метки и типа обновления. Например, версия может выглядеть как "2025-12-13_scheduled_01" для запланированного обновления или "2025-12-13_manual_05" для ручной актуализации. Такой формат делает версии человекочитаемыми и позволяет сразу понять, когда и как было произведено обновление.

Каждый документ, который загружается в RAG, получает в своих метаданных несколько специальных полей. Поле version_id содержит идентификатор версии, к которой принадлежит этот документ. Поле is_active - булевый флаг, указывающий, активен ли этот документ в текущей версии. Поле created_at фиксирует время создания документа. Поле superseded_by может содержать идентификатор более новой версии того же документа, если он был обновлен. Поле source_etl_run_id ссылается на запись в таблице etl_runs в PostgreSQL, что позволяет связать документ с конкретным запуском ETL.

Когда бот-помощник делает запрос к RAG, он явно указывает в параметрах запроса, с какой версией работать. В большинстве случаев это будет последняя активная версия, но система должна поддерживать возможность указать любую предыдущую версию. RAG, получив такой запрос, фильтрует результаты, возвращая только документы, принадлежащие указанной версии и помеченные как активные.

## Процесс создания новой версии

Давайте разберем пошагово, что происходит, когда ETL-pipeline создает новую версию данных. Этот процесс важно понимать детально, потому что именно здесь закладывается основа для последующего отката.

Первый шаг - генерация идентификатора новой версии и создание записи в таблице etl_runs в PostgreSQL. Эта запись получает статус "started" и фиксирует начало процесса обновления. Параллельно в PostgreSQL создается еще одна вспомогательная запись в новой таблице, которую я предлагаю назвать rag_versions.

Таблица rag_versions выглядит примерно так:

```sql
CREATE TABLE rag_versions (
    id BIGSERIAL PRIMARY KEY,
    version_id VARCHAR(100) NOT NULL UNIQUE,
    etl_run_id BIGINT REFERENCES etl_runs(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT false,
    activated_at TIMESTAMP,
    rollback_from_version VARCHAR(100),  -- Если это откат, то от какой версии
    total_documents INTEGER DEFAULT 0,
    active_documents INTEGER DEFAULT 0,
    description TEXT,
    created_by VARCHAR(100)  -- 'system' или ID сотрудника для ручных обновлений
);
```

Эта таблица служит реестром всех версий, которые когда-либо существовали в системе. Она позволяет быстро получить информацию о любой версии без необходимости сканировать все документы в RAG.

Второй шаг - извлечение и обработка новых данных из источников. ETL получает документы из Confluence и закрытые тикеты из Pyrus, очищает их от персональных данных и структурирует в единый формат.

Третий шаг - самый интересный с точки зрения версионирования. Для каждого обработанного документа ETL проверяет, существует ли уже документ с таким же семантическим содержанием в RAG. Это делается через специальный запрос к RAG, который ищет документы с очень высоким совпадением по содержанию или по явному идентификатору источника.

Если документ новый и такого еще нет в RAG, он просто добавляется с метаданными новой версии и флагом is_active установленным в false. Пока новая версия не активирована, эти документы не будут участвовать в поиске.

Если документ обновляет существующий, происходит более сложная операция. Старый документ остается в RAG, но его метаданные обновляются - в поле superseded_by записывается идентификатор новой версии. Новый вариант документа добавляется с флагом is_active установленным в false и с обратной ссылкой на предыдущую версию через поле replaces_document_id.

Четвертый шаг - после успешной загрузки всех документов в RAG происходит активация новой версии. Это атомарная операция, которая переключает систему на работу с новыми данными. В таблице rag_versions для новой версии поле is_active устанавливается в true, а для предыдущей активной версии оно сбрасывается в false. В записи etl_runs статус меняется на "completed". Важно, что старые документы не удаляются и не помечаются как неактивные - они просто больше не возвращаются при поиске, потому что RAG теперь работает с новой версией.

## Механизм отката

Теперь рассмотрим, как работает откат к предыдущей версии. Представьте, что команда обнаружила проблему с последним обновлением и хочет вернуться к предыдущему состоянию базы знаний.

Процесс отката инициируется либо автоматически при обнаружении критических ошибок, либо вручную администратором системы. Он может быть реализован как специальная задача в Pyrus по форме "Откат RAG" или как команда в административном интерфейсе.

Первый шаг отката - определение целевой версии. Система запрашивает из таблицы rag_versions список всех доступных версий и позволяет выбрать ту, к которой нужно откатиться. Обычно это предыдущая версия, но в принципе можно откатиться к любой версии в истории.

Второй шаг - создание новой записи в rag_versions с типом "rollback". Это важная деталь: откат не означает физическое удаление данных или возврат к прошлому состоянию базы. Вместо этого создается новая версия, которая является копией выбранной старой версии. В поле rollback_from_version указывается идентификатор версии, от которой откатываемся.

Третий шаг - переключение активной версии. В таблице rag_versions текущая активная версия помечается как неактивная, а целевая версия отката помечается как активная. При этом никакие документы в RAG не изменяются физически - просто меняется, какая версия считается активной для поиска.

С этого момента все запросы к RAG будут работать с документами выбранной версии. Бот-помощник начнет получать результаты на основе старых данных, которые работали корректно.

Четвертый шаг - создание записи в специальной таблице version_rollbacks для аудита:

```sql
CREATE TABLE version_rollbacks (
    id BIGSERIAL PRIMARY KEY,
    from_version_id VARCHAR(100) NOT NULL,
    to_version_id VARCHAR(100) NOT NULL,
    rollback_reason TEXT,
    initiated_by VARCHAR(100),
    rollback_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    was_successful BOOLEAN DEFAULT true
);
```

Эта таблица ведет полную историю всех откатов, что критически важно для аудита и понимания, какие проблемы возникали с обновлениями.

## Практический пример работы версионирования

Давайте рассмотрим конкретный сценарий, чтобы все стало еще понятнее. Предположим, у вас уже работает система с версией "2025-12-10_scheduled_01", которая содержит тысячу документов из Confluence и закрытых тикетов.

Тринадцатого декабря запускается очередной ETL-pipeline. Он создает новую версию "2025-12-13_scheduled_01" и начинает загружать данные. Из Confluence пришло пятьдесят обновленных страниц и десять новых страниц. Из Pyrus извлечено тридцать закрытых тикетов за последнюю неделю.

Для десяти новых страниц Confluence просто создаются новые документы в RAG с version_id равным "2025-12-13_scheduled_01". Для пятидесяти обновленных страниц система находит их старые версии в RAG, помечает их как superseded, и добавляет новые версии. Тридцать тикетов добавляются как новые документы. В итоге в RAG теперь хранится тысяча девяносто документов: тысяча из предыдущей версии плюс девяносто новых и обновленных.

После успешной загрузки версия "2025-12-13_scheduled_01" активируется. В таблице rag_versions обновляются записи, и теперь при поиске RAG будет возвращать документы из новой версии. Если какой-то документ был обновлен, вернется его новая версия. Если документ не изменился, вернется его старая версия, которая все еще помечена как принадлежащая активной версии через свой version_id.

Через два дня команда замечает, что бот стал давать неправильные ответы на вопросы об интеграциях. После анализа выясняется, что одна из обновленных страниц Confluence содержала устаревшую информацию. Принимается решение откатить систему к предыдущей версии.

Администратор инициирует откат к версии "2025-12-10_scheduled_01". Система создает запись о версии отката "2025-12-15_rollback_01", которая указывает на "2025-12-10_scheduled_01". В таблице rag_versions версия "2025-12-10_scheduled_01" снова помечается как активная. С этого момента RAG возвращает только те документы, которые существовали в версии от десятого декабря. Проблемная страница Confluence больше не влияет на результаты поиска.

Параллельно команда находит и исправляет устаревшую информацию в Confluence. При следующем запуске ETL обновленная и корректная версия страницы будет загружена в RAG как часть новой версии.

## Оптимизация хранения

Важный вопрос, который может возникнуть - не приведет ли такое версионирование к неконтролируемому росту объема данных в RAG? Действительно, если никогда не удалять старые версии документов, база будет постоянно расти.

Для решения этой проблемы я предлагаю реализовать политику очистки старых версий. Например, можно хранить только последние пять или десять версий, а более старые версии архивировать или удалять. Это балансирует между возможностью отката к недавним версиям и разумным использованием дискового пространства.

Очистка может происходить автоматически по расписанию, например раз в месяц. Процесс начинается с запроса к таблице rag_versions для получения списка версий старше определенного порога. Для каждой такой версии система проверяет, не была ли она помечена как критически важная администратором. Если версия не важна и достаточно старая, все её документы, которые не являются частью более новых версий, физически удаляются из RAG.

При этом запись о версии остается в таблице rag_versions с пометкой "archived", что позволяет сохранить историю обновлений даже после физического удаления данных.

## Интеграция с мониторингом

Версионирование открывает интересные возможности для мониторинга качества работы системы. Вы можете сравнивать метрики эффективности бота между разными версиями базы знаний. Если после обновления до новой версии процент успешных ответов бота снизился, это явный сигнал о проблеме с новыми данными.

В таблице bot_performance_metrics можно добавить поле rag_version_id, которое будет связывать метрики с конкретной версией базы знаний. Это позволит строить графики эффективности в разрезе версий и быстро обнаруживать деградацию качества.

Можно даже реализовать автоматический откат при критическом падении метрик. Если система обнаруживает, что после перехода на новую версию процент полностью использованных ответов бота упал более чем на определенный порог, она может автоматически инициировать откат к предыдущей версии и отправить алерт команде.

## Альтернативные подходы

Стоит упомянуть, что существуют и другие подходы к версионированию в RAG. Некоторые решения используют концепцию snapshot'ов - периодических полных снимков состояния базы данных. При откате весь индекс RAG заменяется на предыдущий snapshot. Этот подход проще в реализации, но требует больше дискового пространства и времени на выполнение отката.

Другой подход - использование временных меток на уровне векторной базы данных, где каждый вектор получает временную метку своей валидности. При поиске указывается временная точка, и база возвращает только те векторы, которые были валидны на этот момент. Это элегантное решение, но оно требует, чтобы используемая векторная база данных поддерживала такую функциональность нативно.

Предложенный мной подход с явным версионированием через метаданные представляет собой золотую середину. Он достаточно гибок, не требует специфических возможностей от RAG-системы, и при этом дает полный контроль над процессом управления версиями.

Что важно понимать - версионирование это не просто техническая возможность, это часть культуры непрерывного улучшения системы. Наличие версий позволяет команде смело экспериментировать с новыми источниками данных, способами очистки и структурирования информации, зная что всегда можно безопасно откатиться назад если что-то пойдет не так.

Есть ли какие-то специфические аспекты версионирования, которые вы хотели бы обсудить глубже? Например, как именно реализовать сравнение документов для определения, является ли документ обновлением существующего, или как организовать процесс принятия решения об откате?

### Additional materials